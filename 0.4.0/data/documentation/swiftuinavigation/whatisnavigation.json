{"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"We will define navigation as a “mode” change in an application. The most prototypical example of"},{"type":"text","text":" "},{"type":"text","text":"this in SwiftUI are navigation stacks and links. A user taps a button, and a right-to-left"},{"type":"text","text":" "},{"type":"text","text":"animation transitions you from the current screen to the next screen."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"But there are more examples of navigation beyond that one example. Modal sheets can be thought of"},{"type":"text","text":" "},{"type":"text","text":"as navigation too. They slide from bottom-to-top and transition you from the current screen to a"},{"type":"text","text":" "},{"type":"text","text":"new screen. Full screen covers and popovers are also an example of navigation, as they are very"},{"type":"text","text":" "},{"type":"text","text":"similar to sheets except they either take over the full screen (i.e. covers) or only partially"},{"type":"text","text":" "},{"type":"text","text":"take over the screen (i.e. popovers)."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Even alerts and confirmation dialogs can be thought of navigation as they take full control over"},{"type":"text","text":" "},{"type":"text","text":"the interface and force you to make a selection. It’s also possible for you to define your own"},{"type":"text","text":" "},{"type":"text","text":"notions of navigation, such as bottom sheets, toasts, and more."}]},{"anchor":"State-driven-navigation","level":2,"type":"heading","text":"State-driven navigation"},{"type":"paragraph","inlineContent":[{"type":"text","text":"All of these seemingly disparate examples of navigation can be unified under a single API. The"},{"type":"text","text":" "},{"type":"text","text":"presentation and dismissal of a screen can be described with an optional piece of state. When the"},{"type":"text","text":" "},{"type":"text","text":"state changes from "},{"type":"codeVoice","code":"nil"},{"type":"text","text":" to non-"},{"type":"codeVoice","code":"nil"},{"type":"text","text":" the screen will be presented, whether that be via a"},{"type":"text","text":" "},{"type":"text","text":"drill-down, modal, popover, etc. And when the state changes from non-"},{"type":"codeVoice","code":"nil"},{"type":"text","text":" to "},{"type":"codeVoice","code":"nil"},{"type":"text","text":" the screen will"},{"type":"text","text":" "},{"type":"text","text":"be dismissed."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Driving navigation from state like this can be incredibly powerful:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"It guarantees that your model will always be in sync with the visual representation of the UI."},{"type":"text","text":" "},{"type":"text","text":"It shouldn’t be possible for a piece of state to be non-"},{"type":"codeVoice","code":"nil"},{"type":"text","text":" and not have the corresponding view"},{"type":"text","text":" "},{"type":"text","text":"present."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"It easily enables deep linking capabilities. If all forms of navigation in your application are"},{"type":"text","text":" "},{"type":"text","text":"driven off of state, then you can instantly open your application into any state imaginable by"},{"type":"text","text":" "},{"type":"text","text":"simply constructing a piece of state, handing it to SwiftUI, and letting it do its thing."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"It also allows you to write unit tests for navigation logic without resorting to UI tests, which"},{"type":"text","text":" "},{"type":"text","text":"can be slow, flakey and introduce instability into your test suite. If you write a unit test that"},{"type":"text","text":" "},{"type":"text","text":"shows when a user performs an action that a piece of state went from "},{"type":"codeVoice","code":"nil"},{"type":"text","text":" to non-"},{"type":"codeVoice","code":"nil"},{"type":"text","text":", then you"},{"type":"text","text":" "},{"type":"text","text":"can be assured that the user would be navigated to the next screen."}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"So, this is why state-driven navigation is so great. So, what tools does SwiftUI gives us to embrace"},{"type":"text","text":" "},{"type":"text","text":"this pattern?"}]},{"anchor":"SwiftUIs-tools-for-navigation","level":2,"type":"heading","text":"SwiftUI’s tools for navigation"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Many of SwiftUI’s navigation tools are driven off of optional state, but sadly not all."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The simplest example is modal sheets. A simple API is provided that takes a binding of an optional"},{"type":"text","text":" "},{"type":"text","text":"item, and when that item flips to a non-"},{"type":"codeVoice","code":"nil"},{"type":"text","text":" value it is handed to a content closure to produce"},{"type":"text","text":" "},{"type":"text","text":"a view, and that view is what is animated from bottom-to-top:"}]},{"type":"codeListing","syntax":"swift","code":["func sheet<Item: Identifiable, Content: View>(","  item: Binding<Item?>,","  onDismiss: (() -> Void)? = nil,","  content: @escaping (Item) -> Content",") -> some View"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"When SwiftUI detects the binding flips back to "},{"type":"codeVoice","code":"nil"},{"type":"text","text":", the sheet will automatically be dismissed."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, suppose you have a list of items, and when one is tapped you want to bring up a modal"},{"type":"text","text":" "},{"type":"text","text":"sheet for editing the item:"}]},{"type":"codeListing","syntax":"swift","code":["class FeatureModel: ObservableObject {","  @Published var editingItem: Item?","  func tapped(item: Item) {","    self.editingItem = item","  }","  \/\/ ...","}","","struct FeatureView: View {","  @ObservedObject var model: FeatureModel","","  var body: some View {","    List {","      ForEach(self.model.items) { item in ","        Button(item.name) {","          self.model.tapped(item: item)","        }","      }","    }","    .sheet(item: self.$model.editingItem) { item in ","      EditItemView(item: item)","    }","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This works really great. When the button is tapped, the "},{"type":"codeVoice","code":"tapped(item:)"},{"type":"text","text":" method is called on the"},{"type":"text","text":" "},{"type":"text","text":"model causing the "},{"type":"codeVoice","code":"editingItem"},{"type":"text","text":" state to be hydrated, and then SwiftUI sees that value is no longer"},{"type":"text","text":" "},{"type":"codeVoice","code":"nil"},{"type":"text","text":" and so causes the sheet to be presented."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A lot of SwiftUI’s navigation APIs follow this pattern. For example, here’s the signatures for"},{"type":"text","text":" "},{"type":"text","text":"showing popovers and full screen covers:"}]},{"type":"codeListing","syntax":"swift","code":["func popover<Item, Content>(","  item: Binding<Item?>,","  attachmentAnchor: PopoverAttachmentAnchor = .rect(.bounds),","  arrowEdge: Edge = .top,","  content: @escaping (Item) -> Content",") -> some View where Item : Identifiable, Content : View","","func fullScreenCover<Item, Content>(","  item: Binding<Item?>,","  onDismiss: (() -> Void)? = nil,","  content: @escaping (Item) -> Content",") -> some View where Item : Identifiable, Content : View"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Both take a binding of an optional and a content closure for transforming the non-"},{"type":"codeVoice","code":"nil"},{"type":"text","text":" state into"},{"type":"text","text":" "},{"type":"text","text":"a view that is presented in the popover or cover."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"There are, however, two potential problems with these APIs."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"First, the argument passed to the "},{"type":"codeVoice","code":"content"},{"type":"text","text":" closure is the plain, non-"},{"type":"codeVoice","code":"nil"},{"type":"text","text":" value. This means the"},{"type":"text","text":" "},{"type":"text","text":"sheet view presented is handed a plain, inert value, and if that view wants to make mutations it"},{"type":"text","text":" "},{"type":"text","text":"will need to find a way to communicate that back to the parent. However, two-way communication"},{"type":"text","text":" "},{"type":"text","text":"is already a solved problem in SwiftUI with bindings."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"So, it might be better if the "},{"type":"codeVoice","code":"sheet(item:content:)"},{"type":"text","text":" API handed a binding to the unwrapped item so"},{"type":"text","text":" "},{"type":"text","text":"that any mutations in the sheet would be instantly observable by the parent:"}]},{"type":"codeListing","syntax":"swift","code":[".sheet(item: self.$model.editingItem) { $item in ","  EditItemView(item: $item)","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"However, this is not the API exposed to us from SwiftUI."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The second problem is that while optional state is a great way to drive navigation, it doesn’t"},{"type":"text","text":" "},{"type":"text","text":"scale to multiple navigation destinations."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, suppose that in addition to being able to edit an item, the feature can also add an"},{"type":"text","text":" "},{"type":"text","text":"item and duplicate an item, and you can navigate to a help screen. That can technically be"},{"type":"text","text":" "},{"type":"text","text":"represented as four optionals:"}]},{"type":"codeListing","syntax":"swift","code":["class FeatureModel: ObservableObject {","  @Published var addItem: Item?","  @Published var duplicateItem: Item?","  @Published var editingItem: Item?","  @Published var help: Help?","  \/\/ ...","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"But this is not the most concise way to model this domain. Four optional values means there are"},{"type":"text","text":" "},{"type":"codeVoice","code":"2⁴=16"},{"type":"text","text":" different states this feature can be in, but only 5 of those states are valid. Either all"},{"type":"text","text":" "},{"type":"text","text":"can be "},{"type":"codeVoice","code":"nil"},{"type":"text","text":", representing we are not navigated anywhere, or at most one can be non-"},{"type":"codeVoice","code":"nil"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"representing navigation to a single screen."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"But it is not valid to have 2, 3 or 4 non-"},{"type":"codeVoice","code":"nil"},{"type":"text","text":" values. That would represent multiple screens"},{"type":"text","text":" "},{"type":"text","text":"being simultaneously navigated to, such as two sheets being presented, which is invalid in SwiftUI"},{"type":"text","text":" "},{"type":"text","text":"and can even cause crashes."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This is showing that four optional values is not the best way to represent 4 navigation"},{"type":"text","text":" "},{"type":"text","text":"destinations. Instead, it is more concise to model the 4 destinations as an enum with a case for"},{"type":"text","text":" "},{"type":"text","text":"each destination, and then hold onto a single optional value to represent which destination"},{"type":"text","text":" "},{"type":"text","text":"is currently active:"}]},{"type":"codeListing","syntax":"swift","code":["class FeatureModel: ObservableObject {","  @Published var destination: Destination?","  \/\/ ...","","  enum Destination {","    case add(Item)","    case duplicate(Item)","    case edit(Item)","    case help(Help)","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This allows you to prove that at most one destination can be active at a time. It is impossible"},{"type":"text","text":" "},{"type":"text","text":"to have both an “add” and “duplicate” screen presented at the same time."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"But sadly SwiftUI does not come with the tools necessary to drive navigation off of an optional"},{"type":"text","text":" "},{"type":"text","text":"enum. This is what motivated the creation of this library. It should be possible to represent"},{"type":"text","text":" "},{"type":"text","text":"all of the screens a feature can navigate to as an enum, and then drive sheets, popovers, covers"},{"type":"text","text":" "},{"type":"text","text":"and more from a particular case of that enum."}]},{"anchor":"SwiftUINavigations-tools","level":2,"type":"heading","text":"SwiftUINavigation’s tools"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The tools that ship with this library aim to solve the problems discussed above, and more. There are"},{"type":"text","text":" "},{"type":"text","text":"new APIs for sheets, popovers, covers, alerts, confirmation dialogs "},{"type":"emphasis","inlineContent":[{"type":"text","text":"and"}]},{"type":"text","text":" navigation  links that"},{"type":"text","text":" "},{"type":"text","text":"allow you to model destinations as an enum and drive navigation by a particular case of the enum."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"All of the APIs for these seemingly disparate forms of navigation are unified by a single pattern."},{"type":"text","text":" "},{"type":"text","text":"You first specify a binding to the optional enum driving navigation, and then you specify the case"},{"type":"text","text":" "},{"type":"text","text":"of the enum that you want to isolate."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, the new sheet API now takes a binding to an optional enum, and something known as a"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"http:\/\/github.com\/pointfreeco\/swift-case-paths"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["func sheet<Enum, Case, Content>(","  unwrapping: Binding<Enum?>,","  case: CasePath<Enum, Case>,","  content: @escaping (Binding<Case>) -> Content",") -> some View where Content : View"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This allows you to drive the presentation and dismiss of a sheet from a particular case of an enum."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In order to isolate a specific case of an enum we must make use of our "},{"overridingTitleInlineContent":[{"type":"text","text":"CasePaths"}],"isActive":true,"type":"reference","identifier":"http:\/\/github.com\/pointfreeco\/swift-case-paths","overridingTitle":"CasePaths"},{"type":"text","text":" "},{"type":"text","text":"library. A case path is like a key path, except it is specifically tuned for abstracting over the"},{"type":"text","text":" "},{"type":"text","text":"shape of enums rather than structs. A key path abstractly bundles up the functionality of getting"},{"type":"text","text":" "},{"type":"text","text":"and setting a property on a struct, whereas a case path bundles up the functionality of “extracting”"},{"type":"text","text":" "},{"type":"text","text":"a value from an enum and “embedding” a value into an enum. They are an indispensible tool for"},{"type":"text","text":" "},{"type":"text","text":"transforming bindings."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Similar APIs are defined for popovers, covers, and more."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, consider a feature model that has 3 different destinations that can be navigated to:"}]},{"type":"codeListing","syntax":"swift","code":["class FeatureModel: ObservableObject {","  @Published var destination: Destination?","  \/\/ ...","","  enum Destination {","    case add(Item)","    case duplicate(Item)","    case edit(Item)","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Suppose we want the "},{"type":"codeVoice","code":"add"},{"type":"text","text":" destination to be shown in a sheet, the "},{"type":"codeVoice","code":"duplicate"},{"type":"text","text":" destination to be"},{"type":"text","text":" "},{"type":"text","text":"shown in a popover, and the "},{"type":"codeVoice","code":"edit"},{"type":"text","text":" destination in a drill-down. We can do so easily using the APIs"},{"type":"text","text":" "},{"type":"text","text":"that ship with this library:"}]},{"type":"codeListing","syntax":"swift","code":[".popover(","  unwrapping: self.$model.destination,","  case: \/FeatureModel.Destination.duplicate",") { $item in ","  DuplicateItemView(item: $item)","}",".sheet(","  unwrapping: self.$model.destination,","  case: \/FeatureModel.Destination.add",") { $item in ","  AddItemView(item: $item)","}",".navigationDestination(","  unwrapping: self.$model.destination,","  case: \/FeatureModel.Destination.edit",") { $item in ","  EditItemView(item: $item)","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Even though all 3 forms of navigation are visually quite different, describing how to present them"},{"type":"text","text":" "},{"type":"text","text":"is very consistent. You simply provide the binding to the optional enum held in the model, and then"},{"type":"text","text":" "},{"type":"text","text":"you construct a case path for a particular case, which can be done by prefixing the case with a"},{"type":"text","text":" "},{"type":"text","text":"forward slash."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The above code uses the "},{"type":"codeVoice","code":"navigationDestination"},{"type":"text","text":" view modifier, which is only available in iOS 16."},{"type":"text","text":" "},{"type":"text","text":"If you must support iOS 15 and earlier, you can use the following initializer on "},{"type":"codeVoice","code":"NavigationLink"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which also has a very similar API to the above:"}]},{"type":"codeListing","syntax":"swift","code":["NavigationLink( ","  unwrapping: self.$model.destination,","  case: \/FeatureModel.Destination.edit",") { isActive in ","  self.model.setEditIsActive(isActive)","} destination: { $item in ","  EditItemView(item: $item)","} label: {","  Text(\"\\(item.name)\")","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"That is the basics of using this library’s APIs for driving navigation off of state. Learn more"},{"type":"text","text":" "},{"type":"text","text":"by reading the articles below."}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/swiftuinavigation\/whatisnavigation"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/SwiftUINavigation\/documentation\/SwiftUINavigation\/WhatIsNavigation","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"Learn how one can think of navigation as a domain modeling problem, and how that leads to the"},{"type":"text","text":" "},{"type":"text","text":"creation of concise and testable APIs for navigation."}],"kind":"article","metadata":{"modules":[{"name":"SwiftUINavigation"}],"role":"collectionGroup","title":"What is navigation?"},"hierarchy":{"paths":[["doc:\/\/SwiftUINavigation\/documentation\/SwiftUINavigation"]]},"topicSections":[{"title":"Tools","abstract":[{"type":"text","text":"Read the following articles to learn more about the tools that ship with this library for presenting"},{"type":"text","text":" "},{"type":"text","text":"alerts, dialogs, sheets, popovers, covers, and navigation links all from bindings of enum state."}],"identifiers":["doc:\/\/SwiftUINavigation\/documentation\/SwiftUINavigation\/Navigation","doc:\/\/SwiftUINavigation\/documentation\/SwiftUINavigation\/SheetsPopoversCovers","doc:\/\/SwiftUINavigation\/documentation\/SwiftUINavigation\/AlertsDialogs","doc:\/\/SwiftUINavigation\/documentation\/SwiftUINavigation\/DestructuringViews","doc:\/\/SwiftUINavigation\/documentation\/SwiftUINavigation\/Bindings"]}],"references":{"http://github.com/pointfreeco/swift-case-paths":{"title":"CasePath","titleInlineContent":[{"type":"codeVoice","code":"CasePath"}],"type":"link","identifier":"http:\/\/github.com\/pointfreeco\/swift-case-paths","url":"http:\/\/github.com\/pointfreeco\/swift-case-paths"},"doc://SwiftUINavigation/documentation/SwiftUINavigation/SheetsPopoversCovers":{"role":"article","title":"Sheets, popovers, and covers","abstract":[{"type":"text","text":"Learn how to present sheets, popovers and covers in a concise and testable manner."}],"identifier":"doc:\/\/SwiftUINavigation\/documentation\/SwiftUINavigation\/SheetsPopoversCovers","kind":"article","type":"topic","url":"\/documentation\/swiftuinavigation\/sheetspopoverscovers"},"doc://SwiftUINavigation/documentation/SwiftUINavigation":{"role":"collection","title":"SwiftUINavigation","abstract":[{"type":"text","text":"Tools for making SwiftUI navigation simpler, more ergonomic and more precise."}],"identifier":"doc:\/\/SwiftUINavigation\/documentation\/SwiftUINavigation","kind":"symbol","type":"topic","url":"\/documentation\/swiftuinavigation"},"doc://SwiftUINavigation/documentation/SwiftUINavigation/IfCaseLet":{"role":"symbol","title":"IfCaseLet","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"IfCaseLet"}],"abstract":[{"type":"text","text":"A view that computes content by extracting a case from a binding to an enum and passing a"},{"type":"text","text":" "},{"type":"text","text":"non-optional binding to the case’s associated value to its content closure."}],"identifier":"doc:\/\/SwiftUINavigation\/documentation\/SwiftUINavigation\/IfCaseLet","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"IfCaseLet"}],"url":"\/documentation\/swiftuinavigation\/ifcaselet"},"doc://SwiftUINavigation/documentation/SwiftUINavigation/Bindings":{"role":"article","title":"Bindings","abstract":[{"type":"text","text":"Learn how to manage certain view state, such as "},{"type":"codeVoice","code":"@FocusState"},{"type":"text","text":" directly in your observable object."}],"identifier":"doc:\/\/SwiftUINavigation\/documentation\/SwiftUINavigation\/Bindings","kind":"article","type":"topic","url":"\/documentation\/swiftuinavigation\/bindings"},"doc://SwiftUINavigation/documentation/SwiftUINavigation/AlertsDialogs":{"role":"article","title":"Alerts and dialogs","abstract":[{"type":"text","text":"Learn how to present alerts and confirmation dialogs in a concise and testable manner."}],"identifier":"doc:\/\/SwiftUINavigation\/documentation\/SwiftUINavigation\/AlertsDialogs","kind":"article","type":"topic","url":"\/documentation\/swiftuinavigation\/alertsdialogs"},"doc://SwiftUINavigation/documentation/SwiftUINavigation/DestructuringViews":{"role":"article","title":"Destructuring views","abstract":[{"type":"text","text":"Learn how to use "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftUINavigation\/documentation\/SwiftUINavigation\/IfLet"},{"type":"text","text":", "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftUINavigation\/documentation\/SwiftUINavigation\/IfCaseLet"},{"type":"text","text":" and "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftUINavigation\/documentation\/SwiftUINavigation\/Switch"},{"type":"text","text":" views in order to destructure bindings into"},{"type":"text","text":" "},{"type":"text","text":"smaller parts."}],"identifier":"doc:\/\/SwiftUINavigation\/documentation\/SwiftUINavigation\/DestructuringViews","kind":"article","type":"topic","url":"\/documentation\/swiftuinavigation\/destructuringviews"},"doc://SwiftUINavigation/documentation/SwiftUINavigation/Navigation":{"role":"article","title":"Navigation links and destinations","abstract":[{"type":"text","text":"Learn how to drive navigation in "},{"type":"codeVoice","code":"NavigationView"},{"type":"text","text":" and "},{"type":"codeVoice","code":"NavigationStack"},{"type":"text","text":" in a concise and testable"},{"type":"text","text":" "},{"type":"text","text":"manner."}],"identifier":"doc:\/\/SwiftUINavigation\/documentation\/SwiftUINavigation\/Navigation","kind":"article","type":"topic","url":"\/documentation\/swiftuinavigation\/navigation"},"doc://SwiftUINavigation/documentation/SwiftUINavigation/Switch":{"role":"symbol","title":"Switch","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Switch"}],"abstract":[{"type":"text","text":"A view that can switch over a binding of enum state and exhaustively handle each case."}],"identifier":"doc:\/\/SwiftUINavigation\/documentation\/SwiftUINavigation\/Switch","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Switch"}],"url":"\/documentation\/swiftuinavigation\/switch"},"doc://SwiftUINavigation/documentation/SwiftUINavigation/IfLet":{"role":"symbol","title":"IfLet","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"IfLet"}],"abstract":[{"type":"text","text":"A view that computes content by unwrapping a binding to an optional and passing a non-optional"},{"type":"text","text":" "},{"type":"text","text":"binding to its content closure."}],"identifier":"doc:\/\/SwiftUINavigation\/documentation\/SwiftUINavigation\/IfLet","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"IfLet"}],"url":"\/documentation\/swiftuinavigation\/iflet"}}}