{"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"SwiftUI comes with many property wrappers that can be used in views to drive view state, such as"},{"type":"text","text":" "},{"type":"codeVoice","code":"@FocusState"},{"type":"text","text":". Unfortunately, these property wrappers "},{"type":"emphasis","inlineContent":[{"type":"text","text":"must"}]},{"type":"text","text":" be used in views. It’s not possible"},{"type":"text","text":" "},{"type":"text","text":"to extract this logic to an observable object and integrate it with the rest of the model’s"},{"type":"text","text":" "},{"type":"text","text":"business logic, and be in a better position to test this state."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"We can work around these limitations by introducing a published field to your observable"},{"type":"text","text":" "},{"type":"text","text":"object and synchronizing it to view state with the "},{"type":"codeVoice","code":"bind"},{"type":"text","text":" view modifier that ships with this"},{"type":"text","text":" "},{"type":"text","text":"library."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, suppose you have a sign in flow where if the API request to sign in fails, you want"},{"type":"text","text":" "},{"type":"text","text":"to refocus the email field. The model can be implement like so:"}]},{"type":"codeListing","syntax":"swift","code":["class SignInModel: ObservableObject {","  @Published var email: String","  @Published var password: String","  @Published var focus: Field?","  enum Field { case email, password }","","  func signInButtonTapped() async {","    do {","      try await self.apiClient.signIn(self.email, self.password)","    } catch {","      self.focus = .email","    }","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Notice that we store the focus as a "},{"type":"codeVoice","code":"@Published"},{"type":"text","text":" property in the model rather than "},{"type":"codeVoice","code":"@FocusState"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"This is because "},{"type":"codeVoice","code":"@FocusState"},{"type":"text","text":" only works when installed directly in a view. It cannot be used in"},{"type":"text","text":" "},{"type":"text","text":"an observable object."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can implement the view as you would normally, except you must also us "},{"type":"codeVoice","code":"@FocusState"},{"type":"text","text":" for the"},{"type":"text","text":" "},{"type":"text","text":"focus "},{"type":"emphasis","inlineContent":[{"type":"text","text":"and"}]},{"type":"text","text":" use the "},{"type":"codeVoice","code":"bind"},{"type":"text","text":" helper to make sure that changes to the model’s focus are replayed to"},{"type":"text","text":" "},{"type":"text","text":"the view, and vice versa."}]},{"type":"codeListing","syntax":"swift","code":["struct SignInView: View {","  @FocusState var focus: SignInModel.Field?","  @ObservedObject var model: SignInModel","","  var body: some View {","    Form {","      TextField(\"Email\", text: self.$model.email)","      TextField(\"Password\", text: self.$model.password)","      Button(\"Sign in\") {","        Task {","          await self.model.signInButtonTapped()","        }","      }","    }","    \/\/ ⬇️ Replays changes of `model.focus` to `focus` and vice-versa.","    .bind(self.$model.focus, to: self.$focus)","  }","}"]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/swiftuinavigation\/bindings"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/SwiftUINavigation\/documentation\/SwiftUINavigation\/Bindings","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"Learn how to manage certain view state, such as "},{"type":"codeVoice","code":"@FocusState"},{"type":"text","text":" directly in your observable object."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Bindings","role":"article","modules":[{"name":"SwiftUINavigation"}]},"hierarchy":{"paths":[["doc:\/\/SwiftUINavigation\/documentation\/SwiftUINavigation"],["doc:\/\/SwiftUINavigation\/documentation\/SwiftUINavigation","doc:\/\/SwiftUINavigation\/documentation\/SwiftUINavigation\/WhatIsNavigation"]]},"seeAlsoSections":[{"title":"Tools","identifiers":["doc:\/\/SwiftUINavigation\/documentation\/SwiftUINavigation\/Navigation","doc:\/\/SwiftUINavigation\/documentation\/SwiftUINavigation\/SheetsPopoversCovers","doc:\/\/SwiftUINavigation\/documentation\/SwiftUINavigation\/AlertsDialogs","doc:\/\/SwiftUINavigation\/documentation\/SwiftUINavigation\/DestructuringViews"],"generated":true}],"references":{"doc://SwiftUINavigation/documentation/SwiftUINavigation/WhatIsNavigation":{"role":"collectionGroup","title":"What is navigation?","abstract":[{"type":"text","text":"Learn how one can think of navigation as a domain modeling problem, and how that leads to the"},{"type":"text","text":" "},{"type":"text","text":"creation of concise and testable APIs for navigation."}],"identifier":"doc:\/\/SwiftUINavigation\/documentation\/SwiftUINavigation\/WhatIsNavigation","kind":"article","type":"topic","url":"\/documentation\/swiftuinavigation\/whatisnavigation"},"doc://SwiftUINavigation/documentation/SwiftUINavigation/AlertsDialogs":{"role":"article","title":"Alerts and dialogs","abstract":[{"type":"text","text":"Learn how to present alerts and confirmation dialogs in a concise and testable manner."}],"identifier":"doc:\/\/SwiftUINavigation\/documentation\/SwiftUINavigation\/AlertsDialogs","kind":"article","type":"topic","url":"\/documentation\/swiftuinavigation\/alertsdialogs"},"doc://SwiftUINavigation/documentation/SwiftUINavigation/DestructuringViews":{"role":"article","title":"Destructuring views","abstract":[{"type":"text","text":"Learn how to use "},{"type":"codeVoice","code":"IfLet"},{"type":"text","text":", "},{"type":"codeVoice","code":"IfCaseLet"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Switch"},{"type":"text","text":" views in order to destructure bindings into"},{"type":"text","text":" "},{"type":"text","text":"smaller parts."}],"identifier":"doc:\/\/SwiftUINavigation\/documentation\/SwiftUINavigation\/DestructuringViews","kind":"article","type":"topic","url":"\/documentation\/swiftuinavigation\/destructuringviews"},"doc://SwiftUINavigation/documentation/SwiftUINavigation/Navigation":{"role":"article","title":"Navigation links and destinations","abstract":[{"type":"text","text":"Learn how to drive navigation in "},{"type":"codeVoice","code":"NavigationView"},{"type":"text","text":" and "},{"type":"codeVoice","code":"NavigationStack"},{"type":"text","text":" in a concise and testable"},{"type":"text","text":" "},{"type":"text","text":"manner."}],"identifier":"doc:\/\/SwiftUINavigation\/documentation\/SwiftUINavigation\/Navigation","kind":"article","type":"topic","url":"\/documentation\/swiftuinavigation\/navigation"},"doc://SwiftUINavigation/documentation/SwiftUINavigation/SheetsPopoversCovers":{"role":"article","title":"Sheets, popovers, and covers","abstract":[{"type":"text","text":"Learn how to present sheets, popovers and covers in a concise and testable manner."}],"identifier":"doc:\/\/SwiftUINavigation\/documentation\/SwiftUINavigation\/SheetsPopoversCovers","kind":"article","type":"topic","url":"\/documentation\/swiftuinavigation\/sheetspopoverscovers"},"doc://SwiftUINavigation/documentation/SwiftUINavigation":{"role":"collection","title":"SwiftUINavigation","abstract":[{"type":"text","text":"Tools for making SwiftUI navigation simpler, more ergonomic and more precise."}],"identifier":"doc:\/\/SwiftUINavigation\/documentation\/SwiftUINavigation","kind":"symbol","type":"topic","url":"\/documentation\/swiftuinavigation"}}}